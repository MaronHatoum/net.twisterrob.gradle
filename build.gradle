group = rootProject.name

buildscript {
	repositories {
		jcenter()
	}

	dependencies {
		classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:${VERSION_KOTLIN}"
	}
}

subprojects {
	group = rootProject.group
	version = VERSION

	repositories {
		jcenter()
		google()
		// for Kotlin-DSL
		maven { url 'https://repo.gradle.org/gradle/libs-releases-local/' }
	}

	if ('MVN_LOCALHOST_REPO' in System.env) {
		apply from: 'http://localhost/maven/configure.gradle'
	}
}

allprojects {

	configurations.all {
		resolutionStrategy {
			// make sure we don't have many versions of Kotlin lying around
			force "org.jetbrains.kotlin:kotlin-stdlib:${VERSION_KOTLIN}"
			force "org.jetbrains.kotlin:kotlin-reflect:${VERSION_KOTLIN}"
			force "org.jetbrains.kotlin:kotlin-stdlib-jre7:${VERSION_KOTLIN}"
			force "org.jetbrains.kotlin:kotlin-stdlib-jdk7:${VERSION_KOTLIN}"
			force "org.jetbrains.kotlin:kotlin-stdlib-jre8:${VERSION_KOTLIN}"
			force "org.jetbrains.kotlin:kotlin-stdlib-jdk8:${VERSION_KOTLIN}"
		}
	}

	gradle.projectsEvaluated {
		tasks.withType(JavaCompile) {
			it.options.compilerArgs << "-Xlint:all" << "-Werror"
		}
		tasks.withType(GroovyCompile) {
			it.options.compilerArgs << "-Xlint:all" << "-Werror"
			it.groovyOptions.configurationScript = rootProject.file("gradle/compileGroovy.groovy")
			// enable Java 7 invokeDynamic, since Java target is > 7 (Android requires Java 8 at least)
			// no need for groovy-all:ver-indy, because the classpath is provided from hosting Gradle project
			it.groovyOptions.optimizationOptions.indy = true
		}
		tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile) {
			it.kotlinOptions.verbose = true
			it.kotlinOptions.jvmTarget = (VERSION_JAVA as JavaVersion).toString()
			it.kotlinOptions.allWarningsAsErrors = true
		}
		tasks.withType(Test) {
			if (System.properties.keySet().contains('idea.paths.selector')) {
				it.logger.debug('Keeping folder contents after failed test running from IDEA')
				// see net.twisterrob.gradle.test.GradleRunnerRule
				it.jvmArgs '-Dnet.twisterrob.gradle.runner.clearAfterFailure=false'
			}
		}
	}

	plugins.withId('kotlin') {
		dependencies {
			//implementation 'org.funktionale:funktionale-partials:1.2'
			compileOnly "org.gradle:gradle-kotlin-dsl:${VERSION_KOTLIN_DSL}"
			implementation "org.jetbrains.kotlin:kotlin-stdlib:${VERSION_KOTLIN}"
			implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk8:${VERSION_KOTLIN}"
			implementation "org.jetbrains.kotlin:kotlin-reflect:${VERSION_KOTLIN}"

			testImplementation "org.jetbrains.kotlin:kotlin-test:${VERSION_KOTLIN}"
			testImplementation "org.jetbrains.kotlin:kotlin-test-junit:${VERSION_KOTLIN}"
		}
	}

	plugins.withId('java') {
		sourceCompatibility = VERSION_JAVA as JavaVersion
		targetCompatibility = VERSION_JAVA as JavaVersion
		tasks.test.testLogging.events "passed", "skipped", "failed"
		jar {
			manifest {
				afterEvaluate {
					attributes(
							// Implementation-* used by TestPlugin
							'Implementation-Vendor': project.group,
							'Implementation-Title': project.archivesBaseName,
							'Implementation-Version': project.version,
							// TODO Make sure it doesn't change often (skip for SNAPSHOT)
							// otherwise :jar always re-packages and compilations cascade
							'Built-Date': new Date().format($/yyyy-MM-dd'T'00:00:00Z/$)
					)
				}
			}
		}
	}
}

task('tests', type: TestReport) {
	destinationDir = file("$buildDir/reports/tests/all")
	project.evaluationDependsOnChildren()
	reportOn allprojects.collectMany {Project subproject ->
		subproject.tasks.withType(Test) {Test testTask ->
			testTask.ignoreFailures = true
			testTask.reports.junitXml.enabled = true
		}
	}
	doLast {
		def reportFile = new File(destinationDir, 'index.html')
		if (!(reportFile.text ==~
				/(?s).*<div class="infoBox" id="failures">\s*<div class="counter">0<\/div>.*/)) {
			throw new GradleException("There were failing tests. See the report at: ${reportFile.toURI()}")
		}
	}
}
