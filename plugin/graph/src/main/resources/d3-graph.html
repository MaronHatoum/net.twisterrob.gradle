<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<title>Gradle Task Graph</title>
	<link rel="stylesheet" href="d3-graph.css" />
	<!-- src==xlink:href in svg-->
	<script src="d3.js" charset="utf-8"></script>
	<script src="d3-graph.phys.js"></script>
</head>
<body onload="main()">
	<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" pointer-events="all">
		<defs>
			<radialGradient id="background-gradient" cx="70%" cy="100%" r="90%" fy="60%">
				<stop offset="5%" stop-color="#EFF" />
				<stop offset="95%" stop-color="#DEF" />
			</radialGradient>
			<filter id="negative">
				<feColorMatrix in="SourceGraphic" type="matrix" values="
					-1 0 0 0 1
					0 -1 0 0 1
					0 0 -1 0 1
					0 0 0 1 0
				" />
			</filter>
			<marker id="arrow" viewBox="0,0 10 10" refX="8" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto">
				<path d="M 0 0 L 10 5 L 0 10 z" />
			</marker>
		</defs>
		<rect id="background" width="100%" height="100%" fill="url(#background-gradient)" pointer-events="all" />
		<g id="root">
			<g id="nodes"></g>
			<g id="links"></g>
		</g>
		<g id="legend" transform="translate(80, 50)">
			<rect id="legend-bg" />
		</g>
		<!--<circle r="20" transform="translate(-100, -100)" />-->
	</svg>
	<div id="menu">
		<button onclick="force.stop()">Freeze</button>
		<button onclick="force.resume()">Melt</button>
		<button onclick="force.stop(); zoomFit(0.95, 500)">Fit</button>
	</div>
	<script>//<![CDATA[
function main() {
	// needs extra dispatch because LoadWorker.SUCCEEDED is after window.onload
	setTimeout(function() {
		console.debug("Startup");
		//resize();
		if (window['java'] !== undefined) {
			console.debug("We're in JavaFX");
		} else {
			demo();
			console.debug("We're in a browser");
		}
	}, 0);
}

var zoom = d3.behavior
	.zoom()
	.scaleExtent([1/4, 4])
	.on('zoom.zoom', function () {
		console.trace("zoom", d3.event.translate, d3.event.scale);
		root.attr('transform',
			'translate(' + d3.event.translate + ')'
			+   'scale(' + d3.event.scale     + ')');
	})
;

var svg = d3
	.select('svg')
	.call(zoom)
	//.on('mousemove', function () {
	//	cursor.attr('transform', 'translate(' + d3.mouse(this) + ')');
	//})
;

var demoIdCounter = 0;
svg.select('#background')
	.on('mousedown', function () {
		if(d3.event.which != 2) return;
		d3.event.preventDefault();
		var point = d3.mouse(node_group.node());
		model.add({
			id: '____' + demoIdCounter++ + '____',
			type: 'unknown',
			x: point[0],
			y: point[1]
		});
		/*
		// add links to any nearby nodes
		nodes.forEach(function(target) {
			var x = target.x - node.x,
			    y = target.y - node.y;
			if (Math.sqrt(x * x + y * y) < 30) {
				links.push({source: node, target: target});
			}
		});
		*/
	})
;
//var cursor = svg.select('#cursor');
var root = svg.select('#root');
var node_group = svg.select('#nodes');
var link_group = svg.select('#links');

var force = d3.layout
		.force()
		.gravity(0.03)
		.linkStrength(0.3)
		.charge(-400)
		.on('tick', function tick() {
			//var q = d3.geom.quadtree(nodes);
			//node.each(function(n) { q.visit(phys.collide(n)) });
			// TODO make it finer by 22.5 degree units
			// TODO fix \[  node   ]/ weird edges
			//           \         /
			//    [ node ]\       /[   node  ]
			link
				.attr('x1', function(d) { return phys.lineX(d.source, d.target); })
				.attr('y1', function(d) { return phys.lineY(d.source, d.target); })
				.attr('x2', function(d) { return phys.lineX(d.target, d.source); })
				.attr('y2', function(d) { return phys.lineY(d.target, d.source); })
			;

			node.attr('transform', 	function translate(d) {
				return 'translate(' + d.x + ',' + d.y + ')';
			})
			;
			//zoomFit();
		})
;

var nodes = force.nodes();
var links = force.links();
var node = node_group.selectAll('.node');
var link = link_group.selectAll('.link');
var uiNodes, uiLinks;

d3.select(window).on('resize', resize);
function resize() {
	var width = window.innerWidth, height = window.innerHeight;
	console.trace("Resize", force.size(), [width, height]);
	//zoom.center([width/2, height/2]);
	force.size([width, height]).resume();
	lapsedZoomFit(undefined, 0);
}

function restart(first) {
	link = link.data(links);
	uiLinks = link
		.enter()
		.append('line')
		.each(function(d) { d.ui = this; })
		.attr('id', function(d) {
		 return d.linkId();
		  })
		.attr('class', 'link')
		.style('marker-end', 'url(#arrow)')
	;

	node = node.data(nodes);

	uiNodes = createNodes(node);
	uiNodes
		.on('click', function(d) {
			d3.selectAll('.selected').classed('selected', false);
			d3.select(this).classed('selected', true);
		})
		.call(force
			.drag()
			.on('dragstart', function() {
				d3.event.sourceEvent.stopPropagation();
			})
		)

	force.start();
	if (first) {
		lapsedZoomFit(undefined, 0);
	}
}

function lapsedZoomFit(ticks, transitionDuration) {
	for (var i = ticks || 200; i > 0; --i) force.tick();
	force.stop();
	zoomFit(undefined, transitionDuration);
}

function zoomFit(paddingPercent, transitionDuration) {
	var bounds = root.node().getBBox();
	var parent = root.node().parentElement;
	var fullWidth = parent.clientWidth,
	    fullHeight = parent.clientHeight;
	var width = bounds.width,
	    height = bounds.height;
	var midX = bounds.x + width / 2,
	    midY = bounds.y + height / 2;
	if (width == 0 || height == 0) return;
	var scale = (paddingPercent || 0.75) / Math.max(width / fullWidth, height / fullHeight);
	var translate = [fullWidth / 2 - scale * midX, fullHeight / 2 - scale * midY];

	console.trace("zoomFit", translate, scale);
	root
		.transition()
		.duration(transitionDuration || 0)
		.call(zoom.translate(translate).scale(scale).event);
	//zoom.translate(translate).scale(scale).event(root);
}

var legendData = [
	{ classes: 'skipped', title: 'SKIPPED' },
	{ classes: 'failure', title: 'FAILED' },
	{ classes: 'success' },
	{ classes: 'uptodate', title: 'UP-TO-DATE' },
	{ classes: 'nowork' },
	{ classes: 'executing' },
	{ classes: 'selected' },
	{ classes: 'requested' },
	{ classes: 'unknown' },
	{ classes: 'excluded', title: '--exclude-task' }
];
!function buildLegend() {
	for(var i in legendData) {
		legendData[i].ui = {
			__data__: legendData[i],
			label: function() {
			return this.__data__.title || this.__data__.classes;
			},
			nodeId: function() {
				return 'legend_' + this.__data__.id;
			}
		};
		legendData[i].id = legendData[i].classes.replace(/ /, '-');
	}
	var legend = svg
		.select('#legend');
	var legendNodes = legend
		.selectAll('.node')
		.data(legendData)
	;
	legendNodes = createNodes(legendNodes)
		.attr('class', function(d) { return 'node ' + d.classes; })
		.attr('transform', function(d, i) { return 'translate(0,' + (i * d.height * 1.3) + ')'; })
	;

	var legendBox = legend.node().getBBox();
	var legendPadding = 20;
	var background = legend
		.select('#legend-bg')
		.attr("x", legendBox.x - legendPadding)
		.attr("y", legendBox.y - legendPadding)
		.attr("width", legendBox.width + 2*legendPadding)
		.attr("height", legendBox.height + 2*legendPadding)
	;
}(legendData);

function nodeClasses(d) {
	return 'node' + (d.type? ' ' + d.type : '') + (d.state? ' ' + d.state : '');
}
function createNodes(nodeData) {
	var uiNodes = nodeData
		.enter()
		.append('g')
		.each(function(d) { d.ui.node = this; })
		.attr('id', function(d) { return d.ui.nodeId(); })
	;
	nodeData
		.attr("class", nodeClasses);
	;
	var rect = uiNodes.append('rect')
		.each(function(d) { d.ui.bg = this; })
	;
	var text = uiNodes.append('text')
		.each(function(d) { d.ui.text = this; })
		.text(function(d) { return d.ui.label(); })
	;
	var padding = {x: 6, y: 5};

	rect.attr('width', function(d) { return d.ui.text.clientWidth + 2 * padding.x; })
		.attr('height', function(d) { return d.ui.text.clientHeight + 2 * padding.y; })
		.attr('x', function(d) { return -d.ui.text.clientWidth / 2 - padding.x; })
		.attr('y', function(d) { return -d.ui.text.clientHeight / 2 - padding.y; })
	;

	uiNodes.each(function(d) {
		var box = d.ui.node.getBBox();
		d.width = box.width;
		d.height = box.height;
	});
	return nodeData;
}

var model = function() {
	return {
		init: function(graph) {
			function filter(d) { return d.type == 'unknown'; }
			if (typeof graph === 'string') graph = JSON.parse(graph);

			nodes.length = 0;
			for (var dataIndex in graph) { var data = graph[dataIndex];
				if(filter(data)) continue;
				var node = nodify(dataIndex, data);
				nodes.push(node);
			}
			links.length = 0;
			for (var nodeIndex in graph) {
				var fromNode = graph[nodeIndex];
				if (filter(fromNode)) continue;
				for(var depIndex in fromNode.deps) {
					var toNode = graph[fromNode.deps[depIndex]];
					if (filter(toNode)) continue;
					var link = createLink(fromNode, toNode);
					links.push(link);
					fromNode.links.push(link);
				}
			}
			restart(true);
		},
		update: function(task, result) {
			var node = d3.select('#' + constructNodeId(task));
			var data = node.datum();
			data.state = result;
			node.attr("class", nodeClasses(data));
		},
		add: function(data) {
			nodes.push(nodify(data.id, data));
			restart();
		}
	};
	function cleanName(name) {
		return name.replace(/:/g, '-');
	}
	function constructNodeId(name) {
		return 'node_' + cleanName(name);
	}
	function constructLinkId(from, to) {
		return 'link_' + cleanName(from) + '_' + cleanName(to);
	}
	function nodify(id, node) {
		var defaults = {
			id: id,
			deps: []
		};
		var viewModel = {
			links: [],
			ui: {
				__data__: node,
				node: null,
				text: null,
				bg: null,
				label: function() {
					return this.__data__.label || this.__data__.id;
				},
				nodeId: function() {
					return constructNodeId(this.__data__.id);
				}
			},
			x2: function() {
				return this.x + this.width;
			},
			y2: function() {
				return this.y + this.height;
			}
		};

		for (var i in defaults) {
			if(node[i] === undefined) {
				node[i] = defaults[i];
			}
		}
		for (var i in viewModel) {
			if(node[i] === undefined) {
				node[i] = viewModel[i];
			} else {
				console.error("Property " + i + " already exists", node, viewModel);
			}
		}
		return node; // == $.merge(node, defaults, viewModel);
	}
	function createLink(fromNode, toNode) {
		return {
			source: fromNode,
			target: toNode,
			weight: 1,
			ui: null,
			linkId: function() {
				return constructLinkId(this.source.id, this.target.id);
			}
		};
	}
}();
if (window.java) {
	model = function javafy(model) {
		function javaEntry(name, fun) {
			return function() {
				console.trace(name + "(" + JSON.stringify(arguments) + ")");
				try {
					return fun.apply(this, arguments);
				} catch(e) {
					console.warn(e.name + ": " + e.message + " " + e.stack);
				}
			}
		}
		for(var item in model) {
			if(typeof model[item] === 'function') {
				model[item] = javaEntry(item, model[item]);
			}
		}
		return model;
	}(model);
}


function demo() {
	var allDeps = {
		onlyIf: { deps: []},
		throwTask: { state: "failure", deps: []},
		preBuild: { state: "skipped", deps: ['onlyIf', 'throwTask']},
		preDebugBuild: { state: "success", deps: ['preBuild']},
		checkDebugManifest: { state: "uptodate", deps: ['preDebugBuild']},
		prepareDebugDependencies: { state: "success", deps: [/*'preDebugBuild',*/ 'checkDebugManifest']},
		compileDebugAidl: { deps: ['prepareDebugDependencies']},
		compileDebugRenderscript: { deps: ['prepareDebugDependencies'/*, 'checkDebugManifest'*/]},
		generateDebugBuildConfig: { state: "executing", deps: ['checkDebugManifest']},
		generateDebugAssets: { deps: []},
		mergeDebugAssets: { deps: ['prepareDebugDependencies', 'generateDebugAssets']},
		generateDebugResValues: { deps: []},
		generateDebugResources: { deps: ['generateDebugResValues', 'compileDebugRenderscript']},
		mergeDebugResources: { deps: ['generateDebugResources']},
		processDebugManifest: { deps: ['prepareDebugDependencies']},
		processDebugResources: { deps: [ 'mergeDebugAssets', 'mergeDebugResources', 'processDebugManifest']},
		generateDebugSources: { deps: [/*'compileDebugRenderscript',*/ 'compileDebugAidl', 'processDebugResources', 'generateDebugBuildConfig']},
		processDebugJavaRes: { deps: []},
		compileDebugJava: { type: "nowork", deps: [/*'prepareDebugDependencies',*/ 'processDebugJavaRes', 'generateDebugSources', '_debugCompile' ]},
		compileDebugNdk: { type: "excluded", deps: ['preDebugBuild']},
		compileDebugSources: { deps: ['compileDebugJava', 'compileDebugNdk']},
		preDexDebug: { deps: ['_debugApk']},
		dexDebug: { deps: ['compileDebugJava', 'preDexDebug']},
		validateDebugSigning: { deps: []},
		packageDebug: { deps: [/*'compileDebugJava',*/ 'validateDebugSigning', /*'processDebugJavaRes',*/ 'dexDebug', /*'processDebugResources',*/ 'compileDebugNdk']},
		zipalignDebug: { deps: ['packageDebug']},
		assembleDebug: { type: "requested", deps: ['zipalignDebug', 'compileDebugSources']},
		assembleRelease: { type: "requested", deps: []},
		assemble: { type: "requested", deps: ['assembleRelease', 'assembleDebug']},
		_debugApk: { type: "unknown", deps: []},
		_debugCompile: { type: "unknown", deps: []}
	}

	model.init(allDeps);
	model.update("generateDebugResValues", "success");
}

//]]></script>
</body>
</html>
